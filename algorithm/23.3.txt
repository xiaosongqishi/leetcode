3.17：
给定一个字符串 s ，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。
示例 1：

输入：s = "Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"

my solution:
class Solution:
    def reverseWords(self, s: str) -> str:
        left = 0
        index = 0
        res = ''
        while(1):
            blank = ' '
            index = s[left:].find(blank)
            if index != -1:
                ss = s[left:left+index]
                left = left + index + 1
                res = res + ss[::-1] + ' '
            else:
                break
        ss = s[left:]
        res += ss[::-1]
        return res

ref solution:
class Solution:
    def reverseWords(self, s: str) -> str:
        return ' '.join([w[::-1] for w in s.split(' ')])
-----------------------------------------------------------------------------------------
3.18：
给你单链表的头结点 head ，请你找出并返回链表的中间结点。
如果有两个中间结点，则返回第二个中间结点。        

my solution:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        lens = 0
        l_head = head
        while l_head.next != None:
            l_head = l_head.next
            lens += 1
        if lens % 2 == 0:
            for i in range(int(lens/2)):
                head = head.next
        else:
            for i in range(int(lens//2+1)):
                head = head.next
        return head
缺点：

必须先遍历完整个链表，然后才可以「干正事」，再遍历到一半，找到中间结点；
在链表的长度很长的时候，这种方法之前的等待会很久。        

ref solution:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:
        slow, fast = head, head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
        return slow
使用两个指针变量，刚开始都位于链表的第 1 个结点，一个永远一次只走 1 步，一个永远一次只走 2 步，一个在前，一个在后，同时走。这样当快指针走完的时候，慢指针就来到了链表的中间位置。
思想是：快慢指针的前进方向相同，且它们步伐的「差」是恒定的，根据这种确定性去解决链表中的一些问题。使用这种思想还可以解决链表的以下问题：
-----------------------------------------------------------------------------------------
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
ref solution:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:
        dummy = ListNode(0, head)
        first = head
        second = dummy
        for i in range(n):
            first = first.next

        while first:
            first = first.next
            second = second.next
        
        second.next = second.next.next
        return dummy.next
-----------------------------------------------------------------------------------------
3.19：
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。
示例 1:
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
my solution:
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        temp_len = 0
        lens = [1]
        s_set = {}
        if s == "":
            return 0
        for i in range(len(s)):
            start = i
            ends = i
            while True:
                s_set = set(s[start:ends])
                #print(s_set)
                if len(s_set) == len(s[start:ends]):
                    #print("s_set:", s_set)
                    #print(start,ends,s[start:ends])
                    ends += 1
                    if ends > len(s):
                        lens.append(len(s_set))
                        break
                    continue
                else:
                    lens.append(len(s_set))
                    #print("lens:", lens)
                    s_set = {}
                    break
        return max(lens)
ref solution:
滑动窗口
class Solution:
    def problemName(self, s: str) -> int:
        # Step 1: 定义需要维护的变量们 (对于滑动窗口类题目，这些变量通常是最小长度，最大长度，或者哈希表)
        x, y = ..., ...

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3: 更新需要维护的变量, 有的变量需要一个if语句来维护 (比如最大最小长度)
            x = new_x
            if condition:
                y = new_y

            '''
            ------------- 下面是两种情况，读者请根据题意二选1 -------------
            '''
            # Step 4 - 情况1
            # 如果题目的窗口长度固定：用一个if语句判断一下当前窗口长度是否达到了限定长度 
            # 如果达到了，窗口左指针前移一个单位，从而保证下一次右指针右移时，窗口长度保持不变, 
            # 左指针移动之前, 先更新Step 1定义的(部分或所有)维护变量 
            if 窗口长度达到了限定长度:
                # 更新 (部分或所有) 维护变量 
                # 窗口左指针前移一个单位保证下一次右指针右移时窗口长度保持不变

            # Step 4 - 情况2
            # 如果题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 如果当前窗口不合法时, 用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 在左指针移动之前更新Step 1定义的(部分或所有)维护变量 
            while 不合法:
                # 更新 (部分或所有) 维护变量 
                # 不断移动窗口左指针直到窗口再次合法

        # Step 5: 返回答案
        return ...

class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        # Step 1: 定义需要维护的变量, 本题求最大长度，所以需要定义max_len, 该题又涉及去重，因此还需要一个哈希表
        max_len, hashmap = 0, {}

        # Step 2: 定义窗口的首尾端 (start, end)， 然后滑动窗口
        start = 0
        for end in range(len(s)):
            # Step 3
            # 更新需要维护的变量 (max_len, hashmap)
            # i.e. 把窗口末端元素加入哈希表，使其频率加1，并且更新最大长度
            hashmap[s[end]] = hashmap.get(s[end], 0) + 1
            if len(hashmap) == end - start + 1:
                max_len = max(max_len, end - start + 1)
            
            # Step 4: 
            # 根据题意,  题目的窗口长度可变: 这个时候一般涉及到窗口是否合法的问题
            # 这时要用一个while去不断移动窗口左指针, 从而剔除非法元素直到窗口再次合法
            # 当窗口长度大于哈希表长度时候 (说明存在重复元素)，窗口不合法
            # 所以需要不断移动窗口左指针直到窗口再次合法, 同时提前更新需要维护的变量 (hashmap)
            while end - start + 1 > len(hashmap):
                head = s[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                start += 1
        # Step 5: 返回答案 (最大长度)
        return max_len


-----------------------------------------------------------------------------------------
给你两个字符串 s1 和 s2 ，写一个函数来判断 s2 是否包含 s1 的排列。如果是，返回 true ；否则，返回 false 。
换句话说，s1 的排列之一是 s2 的 子串 。
示例 1：
输入：s1 = "ab" s2 = "eidbaooo"
输出：true
解释：s2 包含 s1 的排列之一 ("ba").

class Solution:
    def checkInclusion(self, s1: str, s2: str) -> bool:
        l_s1 = len(s1)
        hashmap1 ={}
        for i in range(l_s1):
            hashmap1[s1[i]] = hashmap1.get(s1[i],0) + 1
        hashmap = {}
        start = 0
        for end in range(len(s2)):
            hashmap[s2[end]] = hashmap.get(s2[end], 0) + 1
            print(hashmap)
            if hashmap == hashmap1:
                return True
            if end - start + 1 == l_s1:
                head = s2[start]
                hashmap[head] -= 1
                if hashmap[head] == 0:
                    del hashmap[head]
                start += 1
        return False
        
-----------------------------------------------------------------------------------------
3.20：
有一幅以 m x n 的二维整数数组表示的图画 image ，其中 image[i][j] 表示该图画的像素值大小。
你也被给予三个整数 sr ,  sc 和 newColor 。你应该从像素 image[sr][sc] 开始对图像进行 上色填充 。
为了完成 上色工作 ，从初始像素开始，记录初始坐标的 上下左右四个方向上 像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应 四个方向上 像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为 newColor 。
最后返回 经过上色渲染后的图像 。

深度广度优先搜索，用队列：
DFS(队列，先进先出)
my solution:
from queue import Queue # 队列

class Solution:
    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:
        if color == image[sr][sc]:
            return image
        row = len(image) # 行
        column = len(image[0]) # 列
        paintlist = Queue()
        paintlist.put((sr,sc))
        directions = {(1, 0), (-1, 0), (0, 1), (0, -1)}
        originColor = image[sr][sc]
        while not paintlist.empty():
            now_paint = paintlist.get()
            image[now_paint[0]][now_paint[1]] = color
            for direction in directions:
                new_i = now_paint[0] + direction[0]
                new_j = now_paint[1] + direction[1]
                if 0 <= new_i < row and 0 <= new_j < column and image[new_i][new_j] == originColor:
                    paintlist.put((new_i,new_j))
        return image

给你一个大小为 m x n 的二进制矩阵 grid 。
岛屿 是由一些相邻的 1 (代表土地) 构成的组合，这里的「相邻」要求两个 1 必须在 水平或者竖直的四个方向上 相邻。你可以假设 grid 的四个边缘都被 0（代表水）包围着。
岛屿的面积是岛上值为 1 的单元格的数目。
计算并返回 grid 中最大的岛屿面积。如果没有岛屿，则返回面积为 0 。
BFS(栈，后进先出)
my solution:
class Solution:
    def maxAreaOfIsland(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])
        def bfs(i, j):
            queue = [(i, j)]
            grid[i][j] = 0
            area = 1
            while queue:
                x, y = queue.pop(0)
                for dx, dy in ((1, 0), (-1, 0), (0, 1), (0, -1)):
                    nx, ny = x + dx, y + dy
                    if 0 <= nx < m and 0 <= ny < n and grid[nx][ny]:
                        grid[nx][ny] = 0
                        area += 1
                        queue.append((nx, ny))
            return area
        
        res = 0
        for i in range(m):
            for j in range(n):
                if grid[i][j]:
                    res = max(res, bfs(i, j))
        return res

-----------------------------------------------------------------------------------------
3.21：
给你两棵二叉树： root1 和 root2 。

想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。

返回合并后的二叉树。

注意: 合并过程必须从两个树的根节点开始。
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
from queue import Queue
class Solution:
    def mergeTrees(self, root1: Optional[TreeNode], root2: Optional[TreeNode]) -> Optional[TreeNode]:
        # 如果 root1 为空，则合并之后节点为 root2
        if root1 == None:
            return root2
        # 如果 root2 为空，则合并之后节点为 root1
        if root2 == None:
            return root1
        # 如果都存在节点，创建一个新的节点存储合并后的值
        root = TreeNode(root1.val + root2.val)
        # 递归合并左子树
        root.left = self.mergeTrees(root1.left, root2.left)
        # 递归合并右子树
        root.right = self.mergeTrees(root1.right, root2.right)
        return root


给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。

初始状态下，所有 next 指针都被设置为 NULL。

 
"""
# Definition for a Node.
class Node:
    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):
        self.val = val
        self.left = left
        self.right = right
        self.next = next
"""
class Solution(object):
	def connect(self, root):
		"""
		:type root: Node
		:rtype: Node
		"""
		def dfs(root):
			if not root:
				return
			left = root.left
			right = root.right
			# 配合动画演示理解这段，以root为起点，将整个纵深这段串联起来
			while left:
				left.next = right
				left = left.right
				right = right.left
			# 递归的调用左右节点，完成同样的纵深串联
			dfs(root.left)
			dfs(root.right)
		dfs(root)
		return root
-----------------------------------------------------------------------------------------
3.22：
给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。

两个相邻元素间的距离为 1 。
class Solution:
    def updateMatrix(self, mat: List[List[int]]) -> List[List[int]]:
        m, n = len(mat), len(mat and mat[0])
        dir = [(-1,0), (0,1), (1,0), (0,-1)]

        queue = deque()
        for r in range(m):
            for c in range(n):
                if mat[r][c] == 0:
                    queue.append((r, c))
                else:
                    mat[r][c] = -1

        while queue:
            r, c = queue.popleft()
            for dr,dc in dir:
                nr, nc = r + dr, c + dc
                if nr < 0 or nr >= m or nc < 0 or nc >= n or mat[nr][nc] != -1: 
                    continue
                mat[nr][nc] = mat[r][c] + 1
                queue.append((nr, nc))
        return mat

-----------------------------------------------------------------------------------------
3.23：
在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：

值 0 代表空单元格；
值 1 代表新鲜橘子；
值 2 代表腐烂的橘子。
每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。

返回 直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。

class Solution:
    def orangesRotting(self, grid: List[List[int]]) -> int:
        row, col, time = len(grid), len(grid[0]), 0
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        queue = []
        # add the rotten orange to the queue
        for i in range(row):
            for j in range(col):
                if grid[i][j] == 2:
                    queue.append((i, j, time))
        # bfs
        while queue:
            i, j, time = queue.pop(0)
            for di, dj in directions:
                if 0 <= i + di < row and 0 <= j + dj < col and grid[i + di][j + dj] == 1:
                    grid[i + di][j + dj] = 2
                    queue.append((i + di, j + dj, time + 1))
        # if there are still fresh oranges, return -1
        for row in grid:
            if 1 in row: return -1

        return time


将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def mergeTwoLists(self, l1: ListNode, l2: ListNode) -> ListNode:
        if not l1: return l2  # 终止条件，直到两个链表都空
        if not l2: return l1
        if l1.val <= l2.val:  # 递归调用
            l1.next = self.mergeTwoLists(l1.next,l2)
            return l1
        else:
            l2.next = self.mergeTwoLists(l1,l2.next)
            return l2


Given the head of a singly linked list, reverse the list, and return the reversed list.
iterative approach:
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        prev = None
        curr = head 
        while curr is not None:
            next_node = curr.next
            curr.next = prev
            prev = curr
            curr = next_node
        return prev

recursive approach:
class Solution:
    def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
        # base case: empty list or single node list
        if head is None or head.next is None:
            return head
        
        # recursively reverse the rest of the list
        new_head = self.reverseList(head.next)
        
        # reverse the link between head and head.next
        head.next.next = head
        head.next = None
        
        # return the new head of the reversed list
        return new_head
-----------------------------------------------------------------------------------------
3.24：
Q: Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].
You may return the answer in any order.
Example 1:
Input: n = 4, k = 2
Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
Explanation: There are 4 choose 2 = 6 total combinations.
Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.

sol1:
import itertools
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        return list(itertools.combinations(range(1, n+1), k))

sol2(gpt):
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        res = []
        self.combine_helper(n, k, 1, [], res)
        return res
        
    def combine_helper(self, n, k, start, curr, res):
        if len(curr) == k:
            res.append(curr.copy())
            return
        for i in range(start, n+1):
            curr.append(i)
            self.combine_helper(n, k, i+1, curr, res)
            curr.pop()
The combine function takes two integers n and k as input and returns a list of all possible combinations of k numbers chosen from the range [1, n].

The combine_helper function is a recursive helper function that takes four arguments:

n: the upper bound of the range
k: the number of elements in each combination
start: the starting index to generate the combination
curr: a list of the current combination
res: the list of all possible combinations
The function uses backtracking to generate all possible combinations. The base case is when 
the length of the curr list equals k, in which case we append a copy of curr to res and 
return. Otherwise, we iterate over the range from start to n and append each value to curr.
 We then recursively call combine_helper with start set to i+1 to avoid duplicates, and 
 then remove the last element from curr to backtrack and try the next value in the loop.

The main combine function initializes an empty list res, calls the helper function 
combine_helper with start=1 and an empty list curr, and then returns the final list of 
combinations.


Q: Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.

Example 1:

Input: nums = [1,2,3]
Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

sol1:
class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        return list(itertools.permutations(nums))


Q: Given a string s, you can transform every letter individually to be lowercase or uppercase to create another string.

Return a list of all possible strings we could create. Return the output in any order.

 

Example 1:

Input: s = "a1b2"
Output: ["a1b2","a1B2","A1b2","A1B2"]

sol1:
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        ans = [""]
        for i, c in enumerate(s):
            if c.isalpha():
                ans = [a + c.lower() for a in ans] + [a + c.upper() for a in ans]
            else:
                ans = [a + c for a in ans]
        return ans

sol2(gpt):
class Solution:
    def letterCasePermutation(self, s: str) -> List[str]:
        def generate_permutations(s, i, current, output):
            if i == len(s):
                output.append(current)
                return
            
            if s[i].isalpha():
                generate_permutations(s, i+1, current+s[i].lower(), output)
                generate_permutations(s, i+1, current+s[i].upper(), output)
            else:
                generate_permutations(s, i+1, current+s[i], output)
        
        output = []
        generate_permutations(s, 0, "", output)
        return output

-----------------------------------------------------------------------------------------
3.25
Q: 70. Climbing Stairs
sol1(gpt):
class Solution:
    def climbStairs(self, n: int) -> int:
        if n == 0:
            return 1
        if n == 1:
            return 1
        prev1 = 1
        prev2 = 1
        for i in range(2, n+1):
            curr = prev1 + prev2
            prev2 = prev1
            prev1 = curr
        return curr

sol2(ref):
class Solution:
    def climbStairs(self, n: int) -> int:
        dp = [0] * (n+1)
        dp[0] = 1
        dp[1] = 1
        if n <= 1:
            return dp[n]
        for i in range(2,n+1):
            dp[i] = dp[i-1] + dp[i-2]
        return dp[n]

Q: 198. House Robber
sol1(gpt):
class Solution:
    def rob(self, nums: List[int]) -> int:
        n = len(nums)
        if n == 0:
            return 0
        elif n == 1:
            return nums[0]
        dp = [0] * n
        dp[0] = nums[0]
        dp[1] = max(nums[0], nums[1])
        for i in range(2, n):
            dp[i] = max(nums[i] + dp[i-2], dp[i-1])
        return dp[n-1]

sol2(ref):
class Solution:
    def rob(self, nums: List[int]) -> int:
        prev = 0
        curr = 0
        
        # 每次循环，计算“偷到当前房子为止的最大金额”
        for i in nums:
            # 循环开始时，curr 表示 dp[k-1]，prev 表示 dp[k-2]
            # dp[k] = max{ dp[k-1], dp[k-2] + i }
            prev, curr = curr, max(curr, prev + i)
            # 循环结束时，curr 表示 dp[k]，prev 表示 dp[k-1]

        return curr
-----------------------------------------------------------------------------------------
3.26

Q：120. Triangle
sol1(gpt):
class Solution:
    def minimumTotal(self, triangle: List[List[int]]) -> int:
        n = len(triangle)
        # Initialize the DP table with the last row of the triangle
        dp = triangle[-1]
        print(dp)
        # Starting from the second-last row, update the DP table with the minimum path sum
        for i in range(n-2, -1, -1):
            for j in range(len(triangle[i])):
                print("dp[{}]={}+min({},{})".format(j,triangle[i][j],dp[j],dp[j+1]))
                dp[j] = triangle[i][j] + min(dp[j], dp[j+1])
            print(dp)
        # The final value in the DP table will be the minimum path sum from top to bottom
        print(dp)
        return dp[0]


Q: 231. Power of Two

class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        return n > 0 and (n & (n - 1)) == 0

Q: 191. Number of 1 Bits
sol1(ref):
class Solution:
    def hammingWeight(self, n: int) -> int:
        return str(bin(n)).count('1')
sol2(gpt):
class Solution:
    def hammingWeight(n: int) -> int:
        count = 0
        while n > 0:
            if n & 1 == 1:
                count += 1
            n >>= 1
        return count
-----------------------------------------------------------------------------------------
3.27：
Q: 34. Find First and Last Position of Element in Sorted Array
sol1(gpt):
class Solution:
    def searchRange(self, nums: List[int], target: int) -> List[int]:
        if not nums:
            return [-1,-1]
        left = 0
        right = len(nums) - 1
        while left < right:
            mid = (left + right) // 2
            if nums[mid] < target:
                left = mid + 1
            else:
                right = mid
        if nums[left] != target:
            return [-1,-1]
        start = left
        right = len(nums) - 1
        while left < right:
            mid = (left + right) // 2 + 1
            if nums[mid] > target:
                right = mid - 1
            else:
                left = mid
        return [start, right]

Q: 33. Search in Rotated Sorted Array
sol1(gpt):
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        if not nums:
            return 0

        n = len(nums)
        left, right = 0, n-1

        while left < right:
            mid = left + (right - left) // 2
            if nums[mid] == target:
                return mid
            elif nums[mid] > nums[right]:
                if nums[left] <= target < nums[mid]:
                    right = mid - 1
                else:
                    left = mid + 1
            else:
                if nums[mid] < target <= nums[right]:
                    left = mid + 1
                else:
                    right = mid - 1

        return left if nums[left] == target else -1

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
