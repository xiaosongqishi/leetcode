3.19：
给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1：
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
my solution:
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        i = 0
        for i in range(len(nums)):
            number = target - nums[i]
            try:
                if nums.index(number) != i:
                    return [i,nums.index(number)]
                else:
                    continue
            except:
                continue

ref solution:
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        l = len(nums)
        h = {}
        for i, v in enumerate(nums):
            j = h.get(target - v, None)
            if j is not None:
                return [i, j]
            h[v] = i

-----------------------------------------------------------------------------------------
3.20

给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2，另有两个整数 m 和 n ，分别表示 nums1 和 nums2 中的元素数目。

请你 合并 nums2 到 nums1 中，使合并后的数组同样按 非递减顺序 排列。

注意：最终，合并后数组不应由函数返回，而是存储在数组 nums1 中。为了应对这种情况，nums1 的初始长度为 m + n，其中前 m 个元素表示应合并的元素，后 n 个元素为 0 ，应忽略。nums2 的长度为 n 。

class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        nums1[m:] = nums2
        nums1.sort()

ref:
class Solution:
    def merge(self, nums1: List[int], m: int, nums2: List[int], n: int) -> None:
        """
        Do not return anything, modify nums1 in-place instead.
        """
        # for i in range(0,n):
        #     nums1[m+i]=nums2[i]#nums1[m:]=nums2
        # nums1.sort()
        # return nums1
        k = m + n - 1  # 目标数组总长度
        while m > 0 and n > 0:  # 只要两个数组任意一个遍历完
            if nums1[m - 1] > nums2[n - 1]:  # 一数组最后一个比二最后一个大
                nums1[k] = nums1[m - 1]  # 将一数组最后一个移到目标数组最后一个
                m -= 1  # 一数组的指针左移
            else:
                nums1[k] = nums2[n - 1]  # 将二数组最后一个移到目标数组最后一个
                n -= 1  # 将二数组的指针左移
            k -= 1  # 目标数组指针左移
        nums1[:n] = nums2[:n]  # 如果第二个数组未遍历完，说明一数组已排序好，将二数组剪切过来

-----------------------------------------------------------------------------------------
3.23
Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order. 

Example 1:

Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2,2]
Example 2:

Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [4,9]
Explanation: [9,4] is also accepted.

class Solution:
    def intersect(self, nums1: List[int], nums2: List[int]) -> List[int]:
        freq = {}
        res = []
        
        # Count frequency of each element in nums1
        for num in nums1:
            freq[num] = freq.get(num, 0) + 1
        print(freq)
        # Iterate over nums2 and add elements to res if their frequency in freq is > 0
        for num in nums2:
            if num in freq and freq[num] > 0:
                res.append(num)
                freq[num] -= 1
        
        return res

-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
