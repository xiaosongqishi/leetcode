4.2
Q：334 .Increasing Triplet Subsequence
sol(gpt):
class Solution:
    def increasingTriplet(self, nums: List[int]) -> bool:
        if len(nums) < 3:
            return False
        min1 = nums[0] # min1 is the smallest number in the array
        min2 = float('inf') # min2 is the second smallest number in the array
        for i in range(1, len(nums)): # start from the second number
            if nums[i] > min2: # if the current number is bigger than min2, then we find the triplet
                return True
            if nums[i] > min1:  # if the current number is bigger than min1, then we update min2
                min2 = nums[i]
            else:            # if the current number is smaller than min1, then we update min1
                min1 = nums[i]
        return False

Q: 238. Product of Array Except Self
sol(gpt):
class Solution:
    def productExceptSelf(self, nums: List[int]) -> List[int]:
        n = len(nums)
        res = [1] * n
        for i in range(1, n):
            res[i] = res[i - 1] * nums[i - 1]
        right = 1
        for i in range(n - 1, -1, -1):
            res[i] *= right
            right *= nums[i]
        return res

Q: 560. Subarray Sum Equals K
sol(gpt):
class Solution:
    def subarraySum(self, nums: List[int], k: int) -> int:
        count = 0
        prefix_sum = {0:1} # 记录前缀和的出现次数，初始化为{0:1}
        cur_sum = 0 # 当前的前缀和
        for num in nums:
            cur_sum += num
            count += prefix_sum.get(cur_sum - k, 0) # 计算以当前位置为结尾的符合条件的子数组个数
            prefix_sum[cur_sum] = prefix_sum.get(cur_sum, 0) + 1 # 更新前缀和的出现次数
        return count

----------------------------------------------------------------------------------------------
4.3
Q: 415. Add Strings
sol(gpt):
class Solution:
    def addStrings(self, num1: str, num2: str) -> str:
        res = []
        carry = 0
        i, j = len(num1) - 1, len(num2) - 1
        while i >= 0 or j >= 0 or carry:
            if i >= 0:
                carry += int(num1[i])
                i -= 1
            if j >= 0:
                carry += int(num2[j])
                j -= 1
            res.append(str(carry % 10))
            carry //= 10
        return ''.join(res[::-1])

Q: 409. Longest Palindrome
sol(gpt):
class Solution:
    def longestPalindrome(self, s: str) -> int:
        res = 0
        for v in collections.Counter(s).values():
            res += v // 2 * 2
            if res % 2 == 0 and v % 2 == 1:
                res += 1
        return res
----------------------------------------------------------------------------------------------
4.5
Q: 290. Word Pattern
sol(gpt):
class Solution:
    def wordPattern(self, pattern: str, s: str) -> bool:
        words = s.split()
        if len(pattern) != len(words):
            return False
        d = {}
        for i in range(len(pattern)):
            if pattern[i] not in d:
                if words[i] in d.values():
                    return False
                d[pattern[i]] = words[i]
            else:
                if d[pattern[i]] != words[i]:
                    return False
        return True

Q: 763. Partition Labels
sol(gpt):
class Solution:
    def partitionLabels(self, S: str) -> List[int]:
        last = {c: i for i, c in enumerate(S)}
        j = anchor = 0
        ans = []
        for i, c in enumerate(S):
            j = max(j, last[c])
            if i == j:
                ans.append(i - anchor + 1)
                anchor = i + 1
        return ans

Q: 49. Group Anagrams
sol(gpt):
class Solution:
    def groupAnagrams(self, strs: List[str]) -> List[List[str]]:
        d = {}
        for s in strs:
            key = tuple(sorted(s))
            d[key] = d.get(key, []) + [s]
        return list(d.values())

Q: 43 .Multiply Strings
sol(gpt):
class Solution:
    def multiply(self, num1: str, num2: str) -> str:
        m, n = len(num1), len(num2)
        res = [0] * (m + n)
        for i in range(m - 1, -1, -1):
            for j in range(n - 1, -1, -1):
                mul = int(num1[i]) * int(num2[j])
                p1, p2 = i + j, i + j + 1
                sum = mul + res[p2]
                res[p1] += sum // 10
                res[p2] = sum % 10
        while len(res) > 1 and res[0] == 0:
            res.pop(0)
        return ''.join(map(str, res))
----------------------------------------------------------------------------------------------
4.6
Q: 187. Repeated DNA Sequences
sol(gpt):
class Solution:
    def findRepeatedDnaSequences(self, s: str) -> List[str]:
        d = {}
        for i in range(len(s) - 9):
            d[s[i:i + 10]] = d.get(s[i:i + 10], 0) + 1
        return [k for k, v in d.items() if v > 1]
# 解释上述代码
# 1. 遍历字符串s，每次取10个字符，即s[i:i+10]，并将其作为key存入字典d中，value为出现次数
# 2. 遍历字典d，将value大于1的key取出，即为重复的10个字符

Q: 5. Longest Palindromic Substring
sol(gpt):
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2 or s == s[::-1]:
            return s
        start, max_len = 0, 1
        for i in range(1, len(s)):
            even = s[i - max_len:i + 1]
            odd = s[i - max_len - 1:i + 1]
            if i - max_len - 1 >= 0 and odd == odd[::-1]:
                start = i - max_len - 1
                max_len += 2
                continue
            if i - max_len >= 0 and even == even[::-1]:
                start = i - max_len
                max_len += 1
        return s[start:start + max_len]
# 解释上述代码
# 1. 如果s长度小于2或者s本身就是回文串，直接返回s
# 2. 初始化start和max_len，start为回文串的起始位置，max_len为回文串的长度
# 3. 遍历字符串s，每次取两个字符，即s[i:i+2]，并判断其是否为回文串
# 4. 如果是回文串，更新start和max_len
# 5. 返回s[start:start+max_len]

----------------------------------------------------------------------------------------------
4.7
Q: 2 .Add Two Numbers
sol(gpt):
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummy = ListNode(0)
        cur = dummy
        carry = 0
        while l1 or l2:
            x = l1.val if l1 else 0
            y = l2.val if l2 else 0
            sum = x + y + carry
            carry = sum // 10
            cur.next = ListNode(sum % 10)
            cur = cur.next
            if l1:
                l1 = l1.next
            if l2:
                l2 = l2.next
        if carry:
            cur.next = ListNode(1)
        return dummy.next
# 解释上述代码
# 1. 初始化一个dummy节点，用于返回结果
# 2. 初始化一个cur节点，用于遍历链表
# 3. 初始化一个carry变量，用于存储进位
# 4. 遍历链表l1和l2，直到l1和l2都为空
# 5. 如果l1和l2都不为空，取l1和l2的值，如果l1或l2为空，取0
# 6. 计算l1和l2的值以及进位carry的和
# 7. 将和对10取余，作为新节点的值
# 8. 将和对10取整，作为新的进位
# 9. 将新节点加入到cur节点之后
# 10. 将cur节点后移
# 11. 如果l1不为空，l1后移
# 12. 如果l2不为空，l2后移
# 13. 如果carry不为空，将新节点加入到cur节点之后
# 14. 返回dummy.next

Q: 142 .Linked List Cycle II
sol(gpt):
class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow = fast = head
        while fast and fast.next:
            slow = slow.next
            fast = fast.next.next
            if slow == fast:
                break
        if not fast or not fast.next:
            return None
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
# 解释上述代码
# 1. 初始化快慢指针slow和fast，都指向head
# 2. 遍历链表，直到fast为空或者fast.next为空
# 3. 如果fast为空或者fast.next为空，说明链表无环，返回None
# 4. 如果fast和fast.next都不为空，slow后移一位，fast后移两位
# 5. 如果slow和fast相遇，跳出循环
# 6. 初始化slow指针，指向head
# 7. 遍历链表，直到slow和fast相遇
# 8. 返回slow


----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------
